use crate::constants;
use crate::context::context;
use crate::context::context::{HMContext};
use crate::context::context::Type::{
    AiTrainerRewards, NoContext, NoTokenSplitting, RegularDriver, TokenSplittingFleet, OperationalRewards, PayReward,
};
use crate::event::{Event, Type};
use crate::pb::hivemapper::types::v1::{AiTrainerPayment, Burn, InitializedAccount, Mint, NoSplitPayment, OperationalPayment, Output, RegularDriverPayment, TokenSplittingPayment, Transfer as Tr};
use std::ops::Div;
use log::info;
use substreams::errors::Error;

use substreams_solana::pb::sf::solana::r#type::v1::{
    CompiledInstruction, InnerInstructions, TokenBalance, TransactionStatusMeta,
};

use substreams::log;
use substreams_solana::{b58, Address};
use substreams_solana::block_view::InstructionView;
use substreams_solana_program_instructions::token_instruction_2022::TokenInstruction;

pub fn process_compiled_instruction(
    output: &mut Output,
    timestamp: i64,
    trx_hash: &String,
    meta: &TransactionStatusMeta,
    inst_index: u32,
    inst: &CompiledInstruction,
    accounts: &Vec<String>,
) {
    let instruction_program_account = &accounts[inst.program_id_index as usize];

    if instruction_program_account == constants::HONEY_TOKEN_INSTRUCTION_PROGRAM {
        match inst.data[0] {
            constants::HONEY_LIB_TOKEN_SPLITTING_INSTRUCTION_BYTE => {
                let fleet_account = &accounts[inst.accounts[4] as usize];
                let fleet_driver_account = &accounts[inst.accounts[3] as usize];
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(TokenSplittingFleet(context::TokenSplittingFleet {
                            fleet_account: fleet_account.to_owned(),
                            fleet_driver_account: fleet_driver_account.to_owned(),
                        })),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_LIB_REGULAR_DRIVER_INSTRUCTION_BYTE => {
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(RegularDriver(context::RegularDriver {})),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_LIB_NO_TOKEN_SPLITTING_INSTRUCTION_BYTE => {
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(NoTokenSplitting(context::NoTokenSplitting {})),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_PAY_IMAGERY_QA_INVOICE => {
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(AiTrainerRewards(context::AiTrainerRewards {})),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_PAY_OPERATIOANL_REWARD => {
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(OperationalRewards(context::OperationalRewards {})),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_PAY_REWARD => {
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(NoContext()),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_CREATE_ACCOUNT => {}
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_CREATE_ACCOUNT_2 => {}
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_CREATE_ACCOUNT_3 => {}
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_CREATE_ACCOUNT_4 => {}
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_REMOVE_INVOICE => {}
            _ => {
                if constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_IGNORE_LIST.contains(&inst.data[0]) {
                    return;
                }
                panic!("instruction program account HONEY_TOKEN_INSTRUCTION_PROGRAM but found no match trx_hash: {} inst.data: {}", trx_hash, inst.data[0]);
            }
        }
    }

    if instruction_program_account == constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_LIB {
        match inst.data[0] {
            constants::HONEY_LIB_AI_TRAINER_INSTRUCTION_BYTE => {
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(AiTrainerRewards(context::AiTrainerRewards {})),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_LIB_CREATE_ACCOUNT => {}
            constants::HONEY_TOKEN_INSTRUCTION_PROGRAM_LIB_BURN => {
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(NoContext()),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_LIB_BURN_AND_ADD_ADDITIONAL_HONEY_SUPPLY => {
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(NoContext()),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_LIB_BURN => {
                process_inner_instructions(
                    output,
                    timestamp,
                    trx_hash,
                    HMContext {
                        instruction_index: inst_index,
                        r#type: Some(NoContext()),
                    },
                    accounts,
                    &meta.inner_instructions,
                    meta,
                );

                return;
            }
            constants::HONEY_LIB_BURN_MAP_CREDIT => {}
            constants::HONEY_LIB_UPDATE_CREDIT_TO_HONEY_RATE => {}
            _ => {
                panic!("instruction program account HONEY_TOKEN_SPLITTING_CONTRACT but found no match trx_hash: {} inst.data: {}", trx_hash, inst.data[0]);
            }
        }
    }

    // top level transaction without any inner instructions
    if is_token_program_instruction(accounts, inst.program_id_index as usize) {
        match process_token_instruction(trx_hash, timestamp, &inst.data, &inst.accounts, meta, accounts) {
            Err(err) => {
                panic!(
                    "trx_hash {} top level transaction without inner instructions: {}",
                    trx_hash, err
                );
            }
            Ok(ev_option) => {
                if let Some(ev) = ev_option {
                    match ev.r#type {
                        Type::Mint(mint) => {
                            output.mints.push(mint);
                        }
                        Type::Burn(burn) => {
                            output.burns.push(burn);
                        }
                        Type::Transfer(transfer) => {
                            output.transfers.push(transfer);
                        }
                        Type::InitializeAccount(initialize_account) => {
                            output.initialized_account.push(initialize_account);
                        }
                    }
                }
            }
        }

        return;
    }

    process_inner_instructions(
        output,
        timestamp,
        trx_hash,
        HMContext {
            instruction_index: inst_index,
            r#type: Some(NoContext()),
        },
        accounts,
        &meta.inner_instructions,
        meta,
    );
}

pub fn process_inner_instructions(
    output: &mut Output,
    timestamp: i64,
    trx_hash: &String,
    context: HMContext,
    accounts: &Vec<String>,
    inner_instructions: &Vec<InnerInstructions>,
    meta: &TransactionStatusMeta,
) {
    match context.r#type.as_ref().unwrap() {
        TokenSplittingFleet(obj) => {
            let mut manager_mint = None;
            let mut driver_mint = None;
            inner_instructions
                .iter()
                .filter(|&inner_instruction| inner_instruction.index == context.instruction_index)
                .for_each(|inner_instruction| {
                    inner_instruction
                        .instructions
                        .iter()
                        .filter(|&inst| is_token_program_instruction(accounts, inst.program_id_index as usize))
                        .for_each(|inst| {
                            match process_token_instruction(
                                &trx_hash,
                                timestamp,
                                &inst.data,
                                &inst.accounts,
                                meta,
                                accounts,
                            ) {
                                Err(err) => {
                                    panic!("trx_hash {} token splitting fleet: {}", trx_hash, err);
                                }
                                Ok(ev_option) => {
                                    if let Some(ev) = ev_option {
                                        match ev.r#type {
                                            Type::Mint(mint) => {
                                                if mint.to.eq(&obj.fleet_account) {
                                                    manager_mint = Some(mint);
                                                } else if mint.to.eq(&obj.fleet_driver_account) {
                                                    driver_mint = Some(mint);
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        });
                });

            if manager_mint.is_some() && driver_mint.is_some() {
                output.token_splitting_payments.push(TokenSplittingPayment {
                    manager_mint,
                    driver_mint,
                })
            }
        }
        RegularDriver(obj) => {
            process_inner_instructions_mint(
                context.instruction_index,
                trx_hash,
                timestamp,
                inner_instructions,
                meta,
                accounts,
            )
                .into_iter()
                .for_each(|mint| {
                    output
                        .regular_driver_payments
                        .push(RegularDriverPayment { mint: Some(mint) });
                });
        }
        NoTokenSplitting(obj) => {
            process_inner_instructions_mint(
                context.instruction_index,
                trx_hash,
                timestamp,
                inner_instructions,
                meta,
                accounts,
            )
                .into_iter()
                .for_each(|mint| {
                    output.no_split_payments.push(NoSplitPayment { mint: Some(mint) });
                });
        }
        AiTrainerRewards(obj) => {
            log::info!("processing AiTrainerRewards");
            process_inner_instructions_mint(
                context.instruction_index,
                trx_hash,
                timestamp,
                inner_instructions,
                meta,
                accounts,
            )
                .into_iter()
                .for_each(|mint| {
                    log::info!("processing AiTrainerRewards mints");
                    output.ai_trainer_payments.push(AiTrainerPayment { mint: Some(mint) });
                });
        }
        OperationalRewards(obj) => {
            log::info!("processing OperationalRewards");
            process_inner_instructions_mint(
                context.instruction_index,
                trx_hash,
                timestamp,
                inner_instructions,
                meta,
                accounts,
            )
                .into_iter()
                .for_each(|mint| {
                    log::info!("processing operational mints");
                    output.operational_payments.push(OperationalPayment { mint: Some(mint) });
                });
        }
        NoContext() => {
            process_no_context_inner_instructions(
                output,
                context.instruction_index,
                meta,
                &accounts,
                &trx_hash,
                timestamp,
            );
        }
    }
}

pub fn process_no_context_inner_instructions(
    output: &mut Output,
    instruction_index: u32,
    meta: &TransactionStatusMeta,
    accounts: &Vec<String>,
    trx_hash: &String,
    timestamp: i64,
) {
    meta.inner_instructions
        .iter()
        .filter(|inst| inst.index == instruction_index)
        .for_each(|inst| {
            inst.instructions
                .iter()
                .filter(|&inner_instruction| {
                    is_token_program_instruction(accounts, inner_instruction.program_id_index as usize)
                })
                .for_each(|inner_instruction| {
                    match process_token_instruction(
                        trx_hash,
                        timestamp,
                        &inner_instruction.data,
                        &inner_instruction.accounts,
                        meta,
                        accounts,
                    ) {
                        Err(err) => {
                            panic!("trx_hash {} filtering inner instructions: {}", trx_hash, err)
                        }
                        Ok(ev_option) => {
                            if let Some(ev) = ev_option {
                                match ev.r#type {
                                    Type::Mint(mint) => output.mints.push(mint),
                                    Type::Burn(burn) => output.burns.push(burn),
                                    Type::Transfer(transfer) => {
                                        output.transfers.push(transfer);
                                    }
                                    Type::InitializeAccount(initialize_account) => {
                                        output.initialized_account.push(initialize_account);
                                    }
                                }
                            }
                        }
                    }
                })
        });
}



fn process_inner_instructions_mint(
    context_instruction_index: u32,
    trx_hash: &String,
    timestamp: i64,
    inner_instructions: &Vec<InnerInstructions>,
    meta: &TransactionStatusMeta,
    accounts: &Vec<String>,
) -> Vec<Mint> {
    let mut mints = vec![];
    inner_instructions
        .iter()
        .filter(|&inner_instruction| inner_instruction.index == context_instruction_index)
        .for_each(|inner_instruction| {
            inner_instruction
                .instructions
                .iter()
                .filter(|&inst| is_token_program_instruction(accounts, inst.program_id_index as usize))
                .for_each(|inst| {
                    match process_token_instruction(&trx_hash, timestamp, &inst.data, &inst.accounts, meta, accounts) {
                        Err(err) => {
                            panic!("trx_hash {} process inner instructions mint: {}", trx_hash, err);
                        }
                        Ok(ev_option) => {
                            if let Some(ev) = ev_option {
                                match ev.r#type {
                                    Type::Mint(mint) => {
                                        mints.push(mint);
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                });
        });
    return mints;
}


// fn fetch_account_to(account_keys: &Vec<String>, position: u8) -> String {
//     // Instruction account will contain the list of accounts to fetch in the accounts list
//     // inst account pos 0 -> mint_info
//     // inst account pos 1 -> destination_account_info
//     // inst account pos 2 -> owner_info
//     return account_keys[position as usize].to_owned();
// }

fn is_token_program_instruction(accounts: &Vec<String>, program_id_index: usize) -> bool {
    return &accounts[program_id_index] == constants::TOKEN_PROGRAM;
}


pub fn is_honey_token_transfer(pre_token_balances: &Vec<TokenBalance>, account: &Address) -> bool {
    for token_balance in pre_token_balances.iter() {
        if token_balance.owner.eq(&bs58::encode(account).into_string()) && token_balance.mint.eq(&bs58::encode(constants::HONEY_CONTRACT_ADDRESS).into_string()) {
            return true;
        }
    }
    return false;
}
